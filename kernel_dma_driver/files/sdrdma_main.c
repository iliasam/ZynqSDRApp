//Part of this code is taken from here: https://embetronicx.com/tutorials/linux/
//Commands are taken from here: https://github.com/RaspSDR/server/blob/master/zynq/ioctl.h

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/kdev_t.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/uaccess.h> 
#include <linux/fs.h>
#include <asm/io.h>
#include <linux/workqueue.h>
#include <linux/mutex.h>
#include <linux/device.h>
#include <linux/cdev.h>


#include "sfifo.h"


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("iliasam");
MODULE_DESCRIPTION
    ("sdrdma - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "sdrdma"
#define DRIVER_NAME_WF "sdrdma"
#define DIVER_DTS_DEVICE "openzynqsdr"

#define SOUND_BUFFER_LENGTH		200 //bursts
#define SOUND_CH_COUNT	        8
#define SOUND_BURST_SIZE 	    (SOUND_CH_COUNT * 2) //I+Q, size is 4byte words
#define SOUND_BUFFER_SIZE_WORDS (SOUND_BURST_SIZE * SOUND_BUFFER_LENGTH)
#define SOUND_BUFFER_SIZE_BYTES (SOUND_BUFFER_SIZE_WORDS * sizeof(uint32_t))

#define SOUND_FIFO_ITEMS        (3) //each one is SOUND_BUFFER_SIZE_WORDS in size

//Waterfall
#define WF_BUFFER_SIZE_WORDS    (8192) //I+Q, size is 4byte words
#define WF_BUFFER_SIZE_BYTES 	(WF_BUFFER_SIZE_WORDS * sizeof(uint32_t))


#define SOUND_STATE_WORD_OFFSET	(0x1F400000)//DMA state address = 500MByte, sound data follow next
#define WF0_STATE_WORD_OFFSET	(0x1F410000)


#define RX_READ_BAD_SIZE	10
#define RX_READ_NO_DATA		11
#define RX_READ_OK			20

struct sdrdma_local {
	int sound_irq_n;
	uint8_t last_sound_dma_buf;//last filled
    uint32_t *sound_dma_fast_buf0;
    uint32_t *sound_dma_fast_buf1;
    
    uint32_t *wf0_dma_fast_buf0;
    volatile unsigned long *sound_virtual_base;
    uint8_t is_init;
    uint8_t test_cnt;
    uint8_t test_cnt_wf0;
    dev_t sdrdma_dev;
    struct class *dev_class;
    struct cdev etx_cdev;

};

DEFINE_MUTEX(sound_fifo_mutex);


// read RX data
struct rx_read_op {
    uint32_t destination;
    uint32_t length;// length in bytes
    uint32_t result;
} __attribute__((packed));
#define RX_READ _IOWR('Z', 6, struct rx_read_op)

// read wf data oneshot or continues
struct wf_read_op {
    uint16_t channel;
    uint32_t destination;
    uint32_t length;  // length in bytes
    uint32_t result;
} __attribute__((packed));
#define WF_READ _IOWR('Z', 12, struct wf_read_op)

static struct sdrdma_local *global_drv_state_p = NULL;

static uint32_t sound_fifo_buf[SOUND_BUFFER_SIZE_WORDS * SOUND_FIFO_ITEMS];
static sfifo_t sound_fifo;

static uint32_t sound_tmp_buf[SOUND_BUFFER_SIZE_WORDS];
static uint32_t wf_tmp_buf[WF_BUFFER_SIZE_WORDS];


static int 		init_sys_device(void *lp_p);

static int      etx_open(struct inode *inode, struct file *file);
static int      etx_release(struct inode *inode, struct file *file);
static ssize_t  etx_read(struct file *filp, char __user *buf, size_t len,loff_t * off);
static ssize_t  etx_write(struct file *filp, const char *buf, size_t len, loff_t * off);
static long     etx_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

const int16_t tmp_sin_data[16] = {0,4,7,9,10,9,7,4,0,-4,-7,-9,-10,-9,-7,-4};
const int16_t tmp_cos_data[16] = {10,9,7,4,0,-4,-7,-9,-10,-9,-7,-4,0,4,7,9};


static struct file_operations fops =
{
	.owner          = THIS_MODULE,
	.read           = etx_read,
	.write          = etx_write,
	.open           = etx_open,
	.unlocked_ioctl = etx_ioctl,
	.release        = etx_release,
};
//##########################################################################

//Device file operations


static int etx_open(struct inode *inode, struct file *file)
{
	return 0;
}

static int etx_release(struct inode *inode, struct file *file)
{
	return 0;
}

static ssize_t etx_read(struct file *filp, char __user *buf, size_t len, loff_t *off)
{
	return 0;
}


static ssize_t etx_write(struct file *filp, const char __user *buf, size_t len, loff_t *off)
{
	return len;
}

static long etx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	int32_t value = 0;
	struct rx_read_op tmp_sound_struct;
	struct wf_read_op tmp_wf_struct;
	static uint32_t tmp_counter = 0;
	int i;
	
	tmp_counter++;
	
	
	switch(cmd) 
	{
	case RX_READ:
		// void * to, const void __user * from, unsigned long n
		if( copy_from_user(&tmp_sound_struct ,(struct rx_read_op *) arg, sizeof(struct rx_read_op)) )
      	{
     		pr_err("RX_READ copy from err\n");
      	}
      	
      	if (tmp_sound_struct.length != SOUND_BUFFER_SIZE_BYTES)
      	{
      		tmp_sound_struct.result = RX_READ_BAD_SIZE;
      	}
      	else
      	{
      		mutex_lock(&sound_fifo_mutex);

      		if (sound_fifo.amount == 0)
      		{
      			tmp_sound_struct.result = RX_READ_NO_DATA;
      		}
      		else
      		{
      		  	if (tmp_counter < 10)
      			{
      				printk(KERN_INFO "fifo get\n");
      			}
      			sfifo_get(&sound_fifo, (void *)sound_tmp_buf);
      			tmp_sound_struct.result = RX_READ_OK;
      		}
      		
      		mutex_unlock(&sound_fifo_mutex);
      	}
      	
		//void __user * to, const void * from, unsigned long n
		if( copy_to_user((struct rx_read_op *)arg, &tmp_sound_struct, sizeof(struct rx_read_op)) )
		{
       		pr_err("RX_READ copy to err\n");
     	}
     	
     	
     	if (tmp_sound_struct.result == RX_READ_OK)
     	{
     		if (tmp_counter < 10)
      		{
      			printk(KERN_INFO "try to copy\n");
      			//for (i = 0; i < 10; i++)
      			///{
      			//	pr_info("I=%d Q=%d\n", sound_tmp_buf[i*2], sound_tmp_buf[i*2 + 1]);
      			//}
      		}
      			
      		//void __user * to, const void * from, unsigned long n
     		if( copy_to_user((void *)tmp_sound_struct.destination, sound_tmp_buf, sizeof(sound_tmp_buf)) )
			{
       			pr_err("RX_READ copy to err2\n");
     		}
     	}
     	
	break;
    	
    	
    	
	case WF_READ:
		// void * to, const void __user * from, unsigned long n
		if( copy_from_user(&tmp_wf_struct, (struct wf_read_op *) arg, sizeof(struct wf_read_op)) )
      	{
     		pr_err("RX_READ copy from err\n");
      	}
      	
      	if (tmp_wf_struct.length != WF_BUFFER_SIZE_BYTES)
      	{
      		tmp_wf_struct.result = RX_READ_BAD_SIZE;
      	}
      	else
      	{
      		/*
      		mutex_lock(&sound_fifo_mutex);

      		if (sound_fifo.amount == 0)
      		{
      			tmp_wf_struct.result = RX_READ_NO_DATA;
      		}
      		else
      		{
      		  	if (tmp_counter < 10)
      			{
      				printk(KERN_INFO "fifo get\n");
      			}
      			sfifo_get(&sound_fifo, (void *)wf_tmp_buf);
      			tmp_wf_struct.result = RX_READ_OK;
      		}
      		
      		mutex_unlock(&sound_fifo_mutex);
      		*/
      		memcpy((void *)wf_tmp_buf, global_drv_state_p->wf0_dma_fast_buf0, WF_BUFFER_SIZE_BYTES);
      		tmp_wf_struct.result = RX_READ_OK;
      	}
      	
		//void __user * to, const void * from, unsigned long n
		if( copy_to_user((struct wf_read_op *)arg, &tmp_wf_struct, sizeof(struct wf_read_op)) )
		{
       		pr_err("WF RX_READ copy to err\n");
     	}
     	
     	
     	if (tmp_wf_struct.result == RX_READ_OK)
     	{
     		if (tmp_counter < 10)
      		{
      			printk(KERN_INFO "try to copy WF\n");
      			//for (i = 0; i < 10; i++)
      			///{
      			//	pr_info("I=%d Q=%d\n", sound_tmp_buf[i*2], sound_tmp_buf[i*2 + 1]);
      			//}
      		}
      			
      		//void __user * to, const void * from, unsigned long n
     		if( copy_to_user((void *)tmp_wf_struct.destination, wf_tmp_buf, sizeof(wf_tmp_buf)) )
			{
       			pr_err("WF RX_READ copy to err2\n");
     		}
     	}
     	
	break;
    	
    	
	default:
		pr_info("Default\n");
		break;
	}
	return 0;
}


//*********************************************************************


void sound_workqueue_fn(struct work_struct *work); 
 
/*Creating work by Static Method */
DECLARE_WORK(workqueue, sound_workqueue_fn);

/*Workqueue Function*/
void sound_workqueue_fn(struct work_struct *work)
{
	if (global_drv_state_p == NULL)
		return;
	
	
	mutex_lock(&sound_fifo_mutex);
	if (global_drv_state_p->last_sound_dma_buf == 0)
	{
		sfifo_put(&sound_fifo, (void *)global_drv_state_p->sound_dma_fast_buf0);
	}
	else
	{
		sfifo_put(&sound_fifo, (void *)global_drv_state_p->sound_dma_fast_buf1);
	}
	mutex_unlock(&sound_fifo_mutex);
	
	//TEST
	if (global_drv_state_p->test_cnt >= 20)
		return;
		
	uint32_t fifo_amount = sound_fifo.amount;
	printk(KERN_INFO "work idx %d, fifo=%d\n", global_drv_state_p->last_sound_dma_buf, fifo_amount);
}


static irqreturn_t sdrdma_sound_irq_handler(int irq, void *lp_p)
{
	struct sdrdma_local *lp = lp_p;
	uint32_t dma_state;
	
    if (lp->is_init == 0)
    {
        return IRQ_HANDLED;
    }

	dma_state = ioread32(lp->sound_virtual_base);//number of buffer that is filled and ready now
    	
    if (dma_state == 0)
	{
   		memcpy_fromio(lp->sound_dma_fast_buf0, lp->sound_virtual_base + 1, SOUND_BUFFER_SIZE_BYTES);
	}
	else
  	{
		memcpy_fromio(lp->sound_dma_fast_buf1, lp->sound_virtual_base + 1 + SOUND_BUFFER_SIZE_WORDS, SOUND_BUFFER_SIZE_BYTES);
    }
    lp->last_sound_dma_buf = dma_state;
    
	schedule_work(&workqueue);

    if (lp->test_cnt < 20)
    {
    	lp->test_cnt++;
    	printk("sdrdma irq: %d\n", dma_state);
    }
    
    
	return IRQ_HANDLED;
}

static irqreturn_t sdrdma_wf0_irq_handler(int irq, void *lp_p)
{
	struct sdrdma_local *lp = lp_p;
	
	if (lp->test_cnt_wf0 < 20)
    {
    	lp->test_cnt_wf0++;
    	printk("sdrdma wf0 irq: %d\n", 0);
    }
    
	return IRQ_HANDLED;
}

//Used to set new device permissions
static char *devnode(struct device *dev, umode_t *mode)
{
	if (!mode)
		return NULL;
	if (dev->devt == global_drv_state_p->sdrdma_dev)
	{
		printk("Change dev mode to 0666\n");
		*mode = 0666;
	}
	return NULL;
}

static int init_sys_device(void *lp_p)
{
	struct sdrdma_local *lp = lp_p;
	
	/*Allocating Major number*/
	if((alloc_chrdev_region(&lp->sdrdma_dev, 0, 1, "etx_Dev")) <0){
		printk("Cannot allocate major number for device\n");
		return -1;
	}
	printk("Major = %d Minor = %d \n",MAJOR(lp->sdrdma_dev), MINOR(lp->sdrdma_dev));
	
	cdev_init(&lp->etx_cdev, &fops);
	
	/*Adding character device to the system*/
    if((cdev_add(&lp->etx_cdev, lp->sdrdma_dev, 1)) < 0){
		pr_err("Cannot add the device to the system\n");
        goto r_class;
    }
 
	/*Creating struct class*/
	lp->dev_class = class_create(THIS_MODULE, "sdrdma_class");
	if(IS_ERR(lp->dev_class)){
		printk("Cannot create the struct class for device\n");
		goto r_class;
	}
	lp->dev_class->devnode = devnode;
 
	/*Creating device*/
	if(IS_ERR(device_create(lp->dev_class, NULL, lp->sdrdma_dev, NULL, DRIVER_NAME)))
	{
		printk("Cannot create the device class\n");
		goto r_device;
	}
	printk("SDRDMA - Kernel Device created successfully.\n");
	return 0;
 
r_device:
	class_destroy(lp->dev_class);
r_class:
	unregister_chrdev_region(lp->sdrdma_dev, 1);
	return -1;
}


static int sdrdma_probe(struct platform_device *pdev)
{
    int rval;
    struct resource *res;
    struct sdrdma_local *lp = NULL;
    struct device *dev = &pdev->dev;
    int irq_n;
    int irq_n_wf0;
    int i;
 
    printk("Device Tree Probing 9\n"); 
    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
    if (!res) {
      printk(KERN_INFO "could not get platform IRQ resource.\n");
      goto fail_irq;
    }
   
    lp = (struct sdrdma_local *)kmalloc(sizeof(struct sdrdma_local), GFP_KERNEL);
    if (!lp) {
		printk("Can't not allocate memory for sdrdma device\n");
		return -ENOMEM;
    }
    global_drv_state_p = lp;
    dev_set_drvdata(dev, lp);
 
    // save the returned IRQ
    irq_n = res->start;
    lp->sound_irq_n = irq_n;
    lp->is_init = 0;
 
    printk(KERN_INFO "IRQ read form DTS entry as %d\n", irq_n);
 
    rval = request_irq(irq_n, sdrdma_sound_irq_handler, 0, DRIVER_NAME, lp);
    if(rval)
    {
        printk(KERN_INFO "Can't get assigned Sound irq: %d\n", irq_n);
        goto error1;
    }
    
    //************
    res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
    if (!res) {
      printk(KERN_INFO "could not get platform IRQ WF0 resource.\n");
      goto error1_5;
    }
    // save the returned IRQ
    irq_n_wf0 = res->start;
    printk(KERN_INFO "IRQ read form DTS entry as %d\n", irq_n_wf0);
    
    
    //irq_n_wf0 = irq_n + 1;
    rval = request_irq(irq_n_wf0, sdrdma_wf0_irq_handler, 0, DRIVER_NAME_WF, lp);
    if(rval)
    {
        printk(KERN_INFO "Can't get assigned WF irq: %d\n", irq_n_wf0);
        goto error1_5;
    }
   
    lp->sound_dma_fast_buf0 = (uint32_t *)kmalloc(SOUND_BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->sound_dma_fast_buf0) {
		printk("Can't not allocate memory for sdrdma device - fast0\n");
		goto error1;
    }
    
    lp->sound_dma_fast_buf1 = (uint32_t *)kmalloc(SOUND_BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->sound_dma_fast_buf1) {
		printk("Can't not allocate memory for sdrdma device - fast1\n");
        kfree(lp->sound_dma_fast_buf0);
		goto error1;
    }
    
    lp->wf0_dma_fast_buf0 = (uint32_t *)kmalloc(WF_BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->sound_dma_fast_buf1) {
		printk("Can't not allocate memory for sdrdma device - wf0_0\n");
        kfree(lp->sound_dma_fast_buf0);
        kfree(lp->sound_dma_fast_buf1);
		goto error1;
    }
    
    for (i = 0; i < WF_BUFFER_SIZE_WORDS; i++)
    {
    	uint32_t tmp_phase = i % 16;
    	int32_t tmp_i = tmp_cos_data[tmp_phase];
    	int32_t tmp_q = -tmp_sin_data[tmp_phase];
    	uint32_t tmp_item =  (uint32_t)(0x0000FFFF & tmp_i) | ((uint32_t)(tmp_q << 16));
    	lp->wf0_dma_fast_buf0[i] = tmp_item;
    	
    }
    
    
    
    lp->sound_virtual_base = ioremap(SOUND_STATE_WORD_OFFSET, (SOUND_BUFFER_SIZE_WORDS * 2 + 1) * sizeof(uint32_t));//include status reg
    if (!lp->sound_virtual_base)
    {
    	printk("Can't remap memory for sdrdma device\n");
    	goto error2;
    }
    printk("Virt Address 0x%08lx\n", *lp->sound_virtual_base);
	
	rval = init_sys_device(lp);
	if (rval < 0)
		goto error2;
    
    lp->test_cnt = 0;
    lp->is_init = 1;
    
    sfifo_init(&sound_fifo, (void *)sound_fifo_buf, SOUND_BUFFER_SIZE_BYTES, SOUND_FIFO_ITEMS);

   return 0;
 
error2:
	kfree(lp->sound_dma_fast_buf0);
	kfree(lp->sound_dma_fast_buf1);
error1_5:
	free_irq(lp->sound_irq_n, lp);
	printk(KERN_ALERT "Error, IRQ removed, code %d", lp->sound_irq_n);
error1:
	kfree(lp);
	dev_set_drvdata(dev, NULL);
 
fail_irq:
   return -1;
}



static int sdrdma_remove(struct platform_device *pdev)
{
	printk(KERN_ALERT "Removing SDRDMA driver\n");
	struct device *dev = &pdev->dev;
	struct sdrdma_local *lp = dev_get_drvdata(dev);
	free_irq(lp->sound_irq_n, lp);
	printk(KERN_ALERT "IRQ removed, code %d", lp->sound_irq_n);
	free_irq(lp->sound_irq_n + 1, lp);
    printk(KERN_ALERT "WF0 IRQ removed, code %d", lp->sound_irq_n + 1);
    
    kfree(lp->sound_dma_fast_buf0);
    kfree(lp->sound_dma_fast_buf1);
    
    device_destroy(lp->dev_class, lp->sdrdma_dev);
  	class_destroy(lp->dev_class);
  	cdev_del(&lp->etx_cdev);
    unregister_chrdev_region(lp->sdrdma_dev, 1);

	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}


static struct of_device_id sdrdma_of_match[] = {
	{ .compatible = DIVER_DTS_DEVICE, },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, sdrdma_of_match);


static struct platform_driver sdrdma_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= sdrdma_of_match,
	},
	.probe		= sdrdma_probe,
	.remove		= sdrdma_remove,
};

static int __init sdrdma_init(void)
{
	printk("Starting SDRDMA driver.\n");

	return platform_driver_register(&sdrdma_driver);
}


static void __exit sdrdma_exit(void)
{
	platform_driver_unregister(&sdrdma_driver);
	printk(KERN_ALERT "SDRDMA driver done.\n");
}

module_init(sdrdma_init);
module_exit(sdrdma_exit);
