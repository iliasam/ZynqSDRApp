#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/uaccess.h> 
#include <linux/fs.h>
#include <asm/io.h>
#include <linux/workqueue.h>

#include "sfifo.h"

//#include <linux/kfifo.h>


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("iliasam");
MODULE_DESCRIPTION
    ("sdrdma - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "sdrdma"
#define DIVER_DTS_DEVICE "openzynqsdr"

#define BUFFER_LENGTH		200 //bursts
#define CH_COUNT	        8
#define BURST_SIZE 			(CH_COUNT * 2) //I+Q, size is 4byte words
#define BUFFER_SIZE_WORDS   (BURST_SIZE * BUFFER_LENGTH)

//#define SOUND_FIFO_LENGTH_WORDS   (1 << 14)

//#define BUFFER_SIZE_BYTES   (BUFFER_SIZE_WORDS * sizeof(uint32_t))
#define SOUND_FIFO_ITEMS    (3)


#define SOUND_STATE_WORD_OFFSET	(0x1F400000)//DMA state address = 500MByte



struct sdrdma_local {
	int irq;
	uint8_t last_dma_buf;//last filled
    uint32_t *dma_fast_buf0;
    uint32_t *dma_fast_buf1;
    volatile unsigned long *virtual_base;
    uint8_t is_init;
    uint8_t test_cnt;
	//void __iomem *base_addr;
	
	//DECLARE_KFIFO(sound_rx_fifo, uint32_t, SOUND_FIFO_LENGTH_WORDS);
	
};

static struct sdrdma_local *global_drv_state_p = NULL;

static uint32_t sound_fifo_buf[BUFFER_SIZE_WORDS * SOUND_FIFO_ITEMS];
static sfifo_t sound_fifo;



//##########################################################################

void workqueue_fn(struct work_struct *work); 
 
/*Creating work by Static Method */
DECLARE_WORK(workqueue, workqueue_fn);

/*Workqueue Function*/
void workqueue_fn(struct work_struct *work)
{
	if (global_drv_state_p == NULL)
		return;
	
	//if (global_drv_state_p->last_dma_buf == 0)
	//	kfifo_in(&global_drv_state_p->sound_rx_fifo, global_drv_state_p->dma_fast_buf0, BUFFER_SIZE_WORDS);
	
	if (global_drv_state_p->last_dma_buf == 0)
	{
		sfifo_put(&sound_fifo, (void *)global_drv_state_p->dma_fast_buf0);
	}
	
	//TEST
	if (global_drv_state_p->test_cnt >= 20)
		return;
		
	
		
	uint32_t fifo_amount = sound_fifo.amount;
	printk(KERN_INFO "work idx %d, fifo=%d\n", global_drv_state_p->last_dma_buf, fifo_amount);
	
	
}


static irqreturn_t sdrdma_irq(int irq, void *lp_p)
{
	struct sdrdma_local *lp = lp_p;
	uint32_t dma_state;
	//uint32_t dma_dat;
	
    if (lp->is_init == 0)
    {
        return IRQ_HANDLED;
    }

	dma_state = ioread32(lp->virtual_base);//number of buffer that is filled and ready now
    	
    if (dma_state == 0)
	{
   		ioread32_rep(lp->virtual_base + 1, lp->dma_fast_buf0, BUFFER_SIZE_WORDS);
	}
	else
  	{
		ioread32_rep(lp->virtual_base + 1 + BUFFER_SIZE_WORDS, lp->dma_fast_buf1, BUFFER_SIZE_WORDS);
    }
    lp->last_dma_buf = dma_state;
    	
	//printk("sdrdma: %d dat: 0x%08x \n", dma_state, dma_dat);
	schedule_work(&workqueue);
    
        
    if (lp->test_cnt < 20)
    {
    	lp->test_cnt++;
    	printk("sdrdma irq: %d\n", dma_state);
    }
    
    
	return IRQ_HANDLED;
}

static int sdrdma_probe(struct platform_device *pdev)
{
    int rval;
    struct resource *res;
    struct sdrdma_local *lp = NULL;
    struct device *dev = &pdev->dev;
    int irq_n;
 
    printk("Device Tree Probing 7\n"); 
    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
    if (!res) {
      printk(KERN_INFO "could not get platform IRQ resource.\n");
      goto fail_irq;
    }
   
    lp = (struct sdrdma_local *)kmalloc(sizeof(struct sdrdma_local), GFP_KERNEL);
    if (!lp) {
		printk("Can't not allocate memory for sdrdma device\n");
		return -ENOMEM;
    }
    dev_set_drvdata(dev, lp);
 
    // save the returned IRQ
    irq_n = res->start;
    lp->irq = irq_n;
    lp->is_init = 0;
 
    printk(KERN_INFO "IRQ read form DTS entry as %d\n", irq_n);
 
    rval = request_irq(irq_n, sdrdma_irq, 0, DRIVER_NAME, lp);
    if(rval)
    {
        printk(KERN_INFO "Can't get assigned irq: %d\n", irq_n);
        goto error1;
    }
   
    lp->dma_fast_buf0 = (uint32_t *)kmalloc(BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->dma_fast_buf0) {
		printk("Can't not allocate memory for sdrdma device - fast0\n");
		goto error1;
    }
    
    lp->dma_fast_buf1 = (uint32_t *)kmalloc(BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->dma_fast_buf1) {
		printk("Can't not allocate memory for sdrdma device - fast1\n");
        kfree(lp->dma_fast_buf1);
		goto error1;
    }
    
    //lp->virtual_base = ioremap_cache(STATE_WORD_OFFSET, (BUFFER_SIZE_WORDS * 2 + 1) * sizeof(uint32_t));//include status reg
    lp->virtual_base = ioremap(SOUND_STATE_WORD_OFFSET, (BUFFER_SIZE_WORDS * 2 + 1) * sizeof(uint32_t));//include status reg
    if (!lp->virtual_base)
    {
    	printk("Can't remap memory for sdrdma device\n");
    	goto error2;
    }
    printk("Virt Address 0x%08lx\n", *lp->virtual_base);
    
    lp->test_cnt = 0;
    lp->is_init = 1;
    global_drv_state_p = lp;
    sfifo_init(&sound_fifo, (void *)sound_fifo_buf, (BUFFER_SIZE_WORDS * sizeof(uint32_t)), SOUND_FIFO_ITEMS);

   return 0;
 
error2:
	kfree(lp->dma_fast_buf0);
	kfree(lp->dma_fast_buf1);
error1:
	kfree(lp);
	dev_set_drvdata(dev, NULL);
 
fail_irq:
   return -1;
}



static int sdrdma_remove(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct sdrdma_local *lp = dev_get_drvdata(dev);
	free_irq(lp->irq, lp);
    printk(KERN_ALERT "IRQ removed, code %d", lp->irq);
    
    kfree(lp->dma_fast_buf0);
    kfree(lp->dma_fast_buf1);
    
	//iounmap(lp->base_addr);
	//release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}


static struct of_device_id sdrdma_of_match[] = {
	{ .compatible = DIVER_DTS_DEVICE, },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, sdrdma_of_match);


static struct platform_driver sdrdma_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= sdrdma_of_match,
	},
	.probe		= sdrdma_probe,
	.remove		= sdrdma_remove,
};

static int __init sdrdma_init(void)
{
	printk("Starting SDRDMA driver.\n");

	return platform_driver_register(&sdrdma_driver);
}


static void __exit sdrdma_exit(void)
{
	platform_driver_unregister(&sdrdma_driver);
	printk(KERN_ALERT "SDRDMA driver done.\n");
}

module_init(sdrdma_init);
module_exit(sdrdma_exit);
