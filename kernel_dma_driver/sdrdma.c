#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/uaccess.h> 
#include <linux/fs.h>
#include <asm/io.h>


#//include <sys/mman.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("iliasam");
MODULE_DESCRIPTION
    ("sdrdma - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "sdrdma"
#define DIVER_DTS_DEVICE "openzynqsdr"

#define BUFFER_LENGTH		200 //bursts
#define CH_COUNT	        8
#define BURST_SIZE 			(CH_COUNT * 2) //I+Q, size is 4byte words
#define BUFFER_SIZE_WORDS   (BURST_SIZE * BUFFER_LENGTH)

#define STATE_WORD_OFFSET	(0x1F400000)//DMA state address = 500MByte
//#define RAM_WORD_OFFSET		(0x1F400004)//RAM start address = 500MByte + 4byte

struct sdrdma_local {
	int irq;
    uint32_t *dma_fast_buf0;
    uint32_t *dma_fast_buf1;
    volatile unsigned long *virtual_base;
    uint8_t is_init;
    uint8_t test_cnt;
	//void __iomem *base_addr;
};


//##########################################################################

static irqreturn_t sdrdma_irq(int irq, void *lp_p)
{
	struct sdrdma_local *lp = lp_p;
	//uint32_t dma_dat;
	
	//printk("sdrdma interrupt\n");
	
    if (lp->is_init == 0)
    {
        return IRQ_HANDLED;
    }
    
    if (lp->test_cnt < 20)
    {
    	lp->test_cnt++;
    	
    	uint32_t dma_state = ioread32(lp->virtual_base);//number of buffer that is filled and ready now
    	
    	if (dma_state == 0)
    	{
    		//dma_dat = ioread32(lp->virtual_base + 1);
    		ioread32_rep(lp->virtual_base + 1, lp->dma_fast_buf0, BUFFER_SIZE_WORDS);
    	}
    	else
    	{
    		//dma_dat = ioread32(lp->virtual_base + 1 + BUFFER_SIZE_WORDS);
    		ioread32_rep(lp->virtual_base + 1 + BUFFER_SIZE_WORDS, lp->dma_fast_buf1, BUFFER_SIZE_WORDS);
    	}
    	
    	//printk("sdrdma: %d dat: 0x%08x \n", dma_state, dma_dat);
    	printk("sdrdma: %d dat: 0x%08x \n", dma_state);
    }
    
    
	return IRQ_HANDLED;
}

static int sdrdma_probe(struct platform_device *pdev)
{
    int rval;
    struct resource *res;
    struct sdrdma_local *lp = NULL;
    struct device *dev = &pdev->dev;
    int irq_n;
 
    printk("Device Tree Probing 6\n"); 
    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
    if (!res) {
      printk(KERN_INFO "could not get platform IRQ resource.\n");
      goto fail_irq;
    }
   
    lp = (struct sdrdma_local *)kmalloc(sizeof(struct sdrdma_local), GFP_KERNEL);
    if (!lp) {
		printk("Can't not allocate memory for sdrdma device\n");
		return -ENOMEM;
    }
    dev_set_drvdata(dev, lp);
 
    // save the returned IRQ
    irq_n = res->start;
    lp->irq = irq_n;
    lp->is_init = 0;
 
    printk(KERN_INFO "IRQ read form DTS entry as %d\n", irq_n);
 
    rval = request_irq(irq_n, sdrdma_irq, 0, DRIVER_NAME, lp);
    if(rval)
    {
        printk(KERN_INFO "Can't get assigned irq: %d\n", irq_n);
        goto error1;
    }
   
    lp->dma_fast_buf0 = (uint32_t *)kmalloc(BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->dma_fast_buf0) {
		printk("Can't not allocate memory for sdrdma device - fast0\n");
		goto error1;
    }
    
    lp->dma_fast_buf1 = (uint32_t *)kmalloc(BUFFER_SIZE_WORDS * sizeof(uint32_t), GFP_ATOMIC);
    if (!lp->dma_fast_buf1) {
		printk("Can't not allocate memory for sdrdma device - fast1\n");
        kfree(lp->dma_fast_buf1);
		goto error1;
    }
    
    //lp->virtual_base = ioremap_cache(STATE_WORD_OFFSET, (BUFFER_SIZE_WORDS * 2 + 1) * sizeof(uint32_t));//include status reg
    lp->virtual_base = ioremap(STATE_WORD_OFFSET, (BUFFER_SIZE_WORDS * 2 + 1) * sizeof(uint32_t));//include status reg
    if (!lp->virtual_base)
    {
    	printk("Can't remap memory for sdrdma device\n");
    	goto error2;
    }
    printk("Virt Address 0x%08lx\n", *lp->virtual_base);
    
    lp->test_cnt = 0;
    lp->is_init = 1;

   return 0;
 
error2:
	kfree(lp->dma_fast_buf0);
	kfree(lp->dma_fast_buf1);
error1:
	kfree(lp);
	dev_set_drvdata(dev, NULL);
 
fail_irq:
   return -1;
}



static int sdrdma_remove(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct sdrdma_local *lp = dev_get_drvdata(dev);
	free_irq(lp->irq, lp);
    printk(KERN_ALERT "IRQ removed, code %d", lp->irq);
    
    kfree(lp->dma_fast_buf0);
    kfree(lp->dma_fast_buf1);
    
	//iounmap(lp->base_addr);
	//release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
	kfree(lp);
	dev_set_drvdata(dev, NULL);
	return 0;
}


static struct of_device_id sdrdma_of_match[] = {
	{ .compatible = DIVER_DTS_DEVICE, },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, sdrdma_of_match);


static struct platform_driver sdrdma_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= sdrdma_of_match,
	},
	.probe		= sdrdma_probe,
	.remove		= sdrdma_remove,
};

static int __init sdrdma_init(void)
{
	printk("Starting SDRDMA driver.\n");

	return platform_driver_register(&sdrdma_driver);
}


static void __exit sdrdma_exit(void)
{
	platform_driver_unregister(&sdrdma_driver);
	printk(KERN_ALERT "SDRDMA driver done.\n");
}

module_init(sdrdma_init);
module_exit(sdrdma_exit);
